version: 0.1
component: deployment
timeoutInSeconds: 600
shell: bash

env:
  variables:
    CLUSTER_NAME: "oke-cluster"
    NAMESPACE: "default"
  exportedVariables:
    - DEPLOYED_VERSION

steps:
  - type: Command
    name: "Setup kubectl"
    timeoutInSeconds: 300
    command: |
      echo "Setting up kubectl configuration..."
      
      # Get cluster ID from environment or state
      if [ -z "$OKE_CLUSTER_ID" ]; then
        echo "OKE_CLUSTER_ID not set, attempting to get from state..."
        export OKE_CLUSTER_ID=$(state_get OKE_OCID 2>/dev/null || echo "")
      fi
      
      if [ -z "$OKE_CLUSTER_ID" ]; then
        echo "Warning: OKE_CLUSTER_ID not found, kubectl may not work"
      else
        echo "Configuring kubectl for cluster: $OKE_CLUSTER_ID"
        oci ce cluster create-kubeconfig --cluster-id "$OKE_CLUSTER_ID" --file ~/.kube/config --region "${OCI_REGION:-mx-queretaro-1}" --token-version 2.0.0
      fi
      
      # Test kubectl connection
      kubectl cluster-info || echo "Warning: kubectl not properly configured"

  - type: Command
    name: "Create Database Wallet Secret"
    timeoutInSeconds: 300
    command: |
      echo "üîß Creating database wallet secret for Oracle connectivity..."
      
      # Check if wallet files exist in repository
      WALLET_DIR="MtdrSpring/backend/wallet"
      if [ ! -d "$WALLET_DIR" ]; then
        echo "‚ùå ERROR: Wallet directory not found at $WALLET_DIR"
        echo "This is required for database connectivity."
        exit 1
      fi
      
      # Verify required wallet files exist
      REQUIRED_FILES=("cwallet.sso" "ewallet.p12" "keystore.jks" "ojdbc.properties" "sqlnet.ora" "tnsnames.ora" "truststore.jks")
      MISSING_FILES=()
      
      for file in "${REQUIRED_FILES[@]}"; do
        if [ ! -f "$WALLET_DIR/$file" ]; then
          MISSING_FILES+=("$file")
        fi
      done
      
      if [ ${#MISSING_FILES[@]} -gt 0 ]; then
        echo "‚ùå ERROR: Missing required wallet files:"
        printf '  - %s\n' "${MISSING_FILES[@]}"
        echo "All wallet files must be present for database connectivity."
        exit 1
      fi
      
      echo "‚úÖ All required wallet files found"
      
      # Check if secret already exists and recreate it to ensure it's up to date
      if kubectl get secret db-wallet-secret -n ${NAMESPACE} >/dev/null 2>&1; then
        echo "üîÑ Existing wallet secret found, updating it..."
        kubectl delete secret db-wallet-secret -n ${NAMESPACE}
      else
        echo "üÜï Creating new wallet secret..."
      fi
      
      # Create the secret with all wallet files
      kubectl create secret generic db-wallet-secret \
        --namespace=${NAMESPACE} \
        --from-file=cwallet.sso="$WALLET_DIR/cwallet.sso" \
        --from-file=ewallet.p12="$WALLET_DIR/ewallet.p12" \
        --from-file=keystore.jks="$WALLET_DIR/keystore.jks" \
        --from-file=ojdbc.properties="$WALLET_DIR/ojdbc.properties" \
        --from-file=sqlnet.ora="$WALLET_DIR/sqlnet.ora" \
        --from-file=tnsnames.ora="$WALLET_DIR/tnsnames.ora" \
        --from-file=truststore.jks="$WALLET_DIR/truststore.jks"
      
      if [ $? -eq 0 ]; then
        echo "‚úÖ Database wallet secret created successfully!"
        
        # Verify the secret was created with expected keys
        echo "üîç Verifying wallet secret contents..."
        SECRET_KEYS=$(kubectl get secret db-wallet-secret -n ${NAMESPACE} -o jsonpath='{.data}' | jq -r 'keys[]' 2>/dev/null || echo "")
        
        if [ -n "$SECRET_KEYS" ]; then
          echo "üìã Wallet secret contains the following files:"
          echo "$SECRET_KEYS" | while read -r key; do
            echo "  ‚úì $key"
          done
        else
          echo "‚ö†Ô∏è  Warning: Could not verify secret contents (jq may not be available)"
          kubectl get secret db-wallet-secret -n ${NAMESPACE} -o yaml | head -20
        fi
        
        echo "üéØ Wallet secret is ready for use by the application"
      else
        echo "‚ùå ERROR: Failed to create database wallet secret"
        echo "This will prevent the application from connecting to the database."
        exit 1
      fi

  - type: Command
    name: "Use complete deployment file"
    timeoutInSeconds: 300
    command: |
      echo "Using complete-deployment.yaml with parameter substitution..."
      
      # Check if complete-deployment.yaml exists
      if [ -f "complete-deployment.yaml" ]; then
        echo "Found complete-deployment.yaml, using it for deployment"
        
        # Create a copy for parameter substitution
        cp complete-deployment.yaml deployment-manifest.yaml
        
        # Get the built image from build artifacts or use parameter
        if [ -f "build-output.json" ]; then
          BUILT_IMAGE=$(cat build-output.json | grep -o '"image":"[^"]*"' | cut -d'"' -f4)
          echo "Found built image: $BUILT_IMAGE"
          export IMAGE_FULL_NAME="$BUILT_IMAGE"
        elif [ -n "${IMAGE_FULL_NAME}" ]; then
          echo "Using parameter IMAGE_FULL_NAME: $IMAGE_FULL_NAME"
        else
          echo "Using default image"
          export IMAGE_FULL_NAME="mx-queretaro-1.ocir.io/axvteqzybmr1/taskmanager/todolistapp-springboot:latest"
        fi
        
        # Substitute all parameters
        echo "Substituting parameters..."
        sed -i "s|\${IMAGE_FULL_NAME}|${IMAGE_FULL_NAME}|g" deployment-manifest.yaml
        sed -i "s|%TODO_PDB_NAME%|${TODO_PDB_NAME}|g" deployment-manifest.yaml
        sed -i "s|%REGION%|${REGION}|g" deployment-manifest.yaml  
        sed -i "s|%UI_USERNAME%|${UI_USERNAME}|g" deployment-manifest.yaml
        
        echo "Parameter substitution completed"
        echo "Using complete-deployment.yaml as deployment manifest"
        
      else
        echo "complete-deployment.yaml not found, will create manifest inline"
        export USE_INLINE_MANIFEST=true
      fi

  - type: Command
    name: "Prepare deployment manifest"
    timeoutInSeconds: 300
    command: |
      # Only create inline manifest if complete-deployment.yaml wasn't used
      if [ "$USE_INLINE_MANIFEST" = "true" ]; then
        echo "Preparing deployment manifest with dynamic image..."
        
        # Get the built image from build artifacts
        if [ -f "build-output.json" ]; then
          BUILT_IMAGE=$(cat build-output.json | grep -o '"image":"[^"]*"' | cut -d'"' -f4)
          echo "Found built image: $BUILT_IMAGE"
          export IMAGE_FULL_NAME="$BUILT_IMAGE"
        else
          echo "build-output.json not found, using default image"
          export IMAGE_FULL_NAME="mx-queretaro-1.ocir.io/axvteqzybmr1/taskmanager/todolistapp-springboot:latest"
        fi
      
      # Create deployment manifest with current image
      cat > deployment-manifest.yaml << EOF
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: agile-deployment
        namespace: ${NAMESPACE}
      spec:
        replicas: 2
        selector:
          matchLabels:
            app: agile-app
        template:
          metadata:
            labels:
              app: agile-app
              version: v1
          spec:
            containers:
              - name: agile-container
                image: ${IMAGE_FULL_NAME}
                imagePullPolicy: Always
                env:
                  - name: db_user
                    value: "TODOUSER"
                  - name: db_url
                    value: "jdbc:oracle:thin:@%TODO_PDB_NAME%_tp?TNS_ADMIN=/mtdrworkshop/creds"
                  - name: todo.table.name
                    value: "todoitem"
                  - name: driver_class_name
                    value: "oracle.jdbc.OracleDriver"
                  - name: OCI_REGION
                    value: "%REGION%"
                  - name: dbpassword
                    valueFrom:
                      secretKeyRef:
                        name: dbuser
                        key: dbpassword
                        optional: true
                  - name: ui_username
                    value: "%UI_USERNAME%"
                  - name: ui_password
                    valueFrom:
                      secretKeyRef:
                        name: frontendadmin
                        key: password
                        optional: true
                volumeMounts:
                  - name: creds
                    mountPath: /mtdrworkshop/creds
                ports:
                  - containerPort: 8080
                readinessProbe:
                  httpGet:
                    path: /test-simple
                    port: 8080
                  initialDelaySeconds: 30
                  periodSeconds: 10
                  timeoutSeconds: 5
                  failureThreshold: 3
                livenessProbe:
                  httpGet:
                    path: /health
                    port: 8080
                  initialDelaySeconds: 60
                  periodSeconds: 30
                  timeoutSeconds: 5
                  failureThreshold: 3
            restartPolicy: Always
            volumes:
              - name: creds
                secret:
                  secretName: db-wallet-secret
            topologySpreadConstraints:
              - maxSkew: 1
                topologyKey: kubernetes.io/hostname 
                whenUnsatisfiable: DoNotSchedule
                labelSelector:
                  matchLabels:
                    app: agile-app
      ---
      apiVersion: v1
      kind: Service
      metadata:
        name: agile-service
        namespace: ${NAMESPACE}
        annotations:
          oci.oraclecloud.com/loadbalancer-policy: "IP_HASH"
      spec:
        type: LoadBalancer
        externalTrafficPolicy: Cluster
        ports:
          - port: 80
            protocol: TCP
            targetPort: 8080
        selector:
          app: agile-app
      ---
      apiVersion: v1
      kind: Service
      metadata:
        name: agile-backend-router
        namespace: ${NAMESPACE}
      spec:
        selector:
          app: agile-app
        ports:
          - protocol: TCP
            port: 80
            targetPort: http
      EOF
        
        echo "Deployment manifest created successfully"
        
        # Substitute parameters
        echo "Substituting deployment parameters..."
        sed -i "s/%TODO_PDB_NAME%/${TODO_PDB_NAME}/g" deployment-manifest.yaml
        sed -i "s/%REGION%/${REGION}/g" deployment-manifest.yaml  
        sed -i "s/%UI_USERNAME%/${UI_USERNAME}/g" deployment-manifest.yaml
        
        echo "Parameter substitution completed"
      else
        echo "Skipping inline manifest creation - using complete-deployment.yaml"
      fi

  - type: Command
    name: "Deploy to OKE"
    timeoutInSeconds: 600
    command: |
      echo "Deploying application to OKE cluster..."
      
      # Apply the deployment
      kubectl apply -f deployment-manifest.yaml
      
      if [ $? -eq 0 ]; then
        echo "Deployment applied successfully"
        
        # Wait for rollout to complete
        echo "Waiting for deployment rollout..."
        kubectl rollout status deployment/agile-deployment -n ${NAMESPACE} --timeout=300s
        
        # Get deployment status
        kubectl get deployments -n ${NAMESPACE} -l app=agile-app
        kubectl get pods -n ${NAMESPACE} -l app=agile-app
        kubectl get services -n ${NAMESPACE} -l app=agile-app
        
        # Export deployed version
        export DEPLOYED_VERSION="${IMAGE_FULL_NAME}"
        echo "Successfully deployed version: $DEPLOYED_VERSION"
        
      else
        echo "Deployment failed!"
        exit 1
      fi

  - type: Command
    name: "Verify deployment"
    timeoutInSeconds: 300
    command: |
      echo "Verifying deployment health..."
      
      # Check pod status
      kubectl get pods -n ${NAMESPACE} -l app=agile-app -o wide
      
      # Check service endpoints
      kubectl get svc -n ${NAMESPACE} agile-service -o wide
      
      # Get load balancer IP (if available)
      EXTERNAL_IP=$(kubectl get svc -n ${NAMESPACE} agile-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
      
      if [ -n "$EXTERNAL_IP" ]; then
        echo "Load Balancer External IP: $EXTERNAL_IP"
        echo "Application should be accessible at: http://$EXTERNAL_IP"
        
        # Test database connectivity through the application
        echo "üîç Testing database connectivity..."
        sleep 30  # Wait for application to fully start
        
        # Test the /status endpoint which should show database connectivity
        HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "http://$EXTERNAL_IP/status" || echo "000")
        if [ "$HTTP_CODE" = "200" ]; then
          echo "‚úÖ Application /status endpoint is responding (HTTP $HTTP_CODE)"
          
          # Test a database-dependent endpoint
          LOGIN_CODE=$(curl -s -o /dev/null -w "%{http_code}" -X POST \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "telefono=3121539670&contrasena=contrasenaSegura1" \
            "http://$EXTERNAL_IP/login" || echo "000")
          
          if [ "$LOGIN_CODE" = "200" ] || [ "$LOGIN_CODE" = "302" ]; then
            echo "‚úÖ Database connectivity test passed (HTTP $LOGIN_CODE)"
            echo "üéâ Deployment successful with working database connection!"
          else
            echo "‚ö†Ô∏è  Database connectivity test failed (HTTP $LOGIN_CODE)"
            echo "Application deployed but database endpoints may have issues"
          fi
        else
          echo "‚ö†Ô∏è  Application not yet responding (HTTP $HTTP_CODE)"
          echo "May need more time to start up"
        fi
      else
        echo "Load Balancer IP not yet assigned, check later with:"
        echo "kubectl get svc -n ${NAMESPACE} agile-service --watch"
      fi
      
      # Verify wallet secret is properly mounted
      echo "üîç Verifying wallet secret is mounted in pods..."
      POD_NAME=$(kubectl get pods -n ${NAMESPACE} -l app=agile-app -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
      
      if [ -n "$POD_NAME" ]; then
        echo "Checking wallet files in pod: $POD_NAME"
        kubectl exec -n ${NAMESPACE} "$POD_NAME" -- ls -la /tmp/wallet/ 2>/dev/null || echo "‚ö†Ô∏è  Could not list wallet files in pod"
      else
        echo "‚ö†Ô∏è  No pods found to verify wallet mounting"
      fi
      
      echo "Deployment verification completed"

outputArtifacts:
  - name: deployment-status
    type: GENERIC_FILE
    location: deployment-manifest.yaml
